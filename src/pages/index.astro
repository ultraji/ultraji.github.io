---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';
---

<!doctype html>
<html lang="zh-CN">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
		<style is:global>
			main {
				width: var(--content-width);
				max-width: var(--content-max-width);
				margin: auto;
				padding: 1em 1em;
			}
			.memos-list {
				display: flex;
				flex-direction: column;
				gap: 0.5rem;
			}
			.memo-card {
				padding: 1rem 1.5rem;
				border: 1px solid rgba(var(--gray), 25%);
				border-radius: 8px;
				background: white;
				transition: box-shadow 0.2s ease;
			}
			.memo-card:hover {
				box-shadow: var(--box-shadow);
			}
			.memo-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 0.5rem;
				font-size: 0.75em;
				color: rgb(var(--gray));
			}
			.memo-date {
				font-weight: 500;
			}
			.memo-time {
				color: rgb(var(--gray));
			}
			.memo-content {
				line-height: 1.6;
				word-break: break-word;
				font-size: 0.85em;
				color: rgb(var(--black));
			}
			.memo-content p {
				margin: 0.5em 0;
			}
			.memo-content h1,
			.memo-content h2,
			.memo-content h3,
			.memo-content h4,
			.memo-content h5,
			.memo-content h6 {
				margin: 0.75em 0 0.5em;
				font-weight: 600;
				color: rgb(var(--black));
				line-height: 1.3;
			}
			.memo-content h1 { font-size: 1.4em; }
			.memo-content h2 { font-size: 1.25em; }
			.memo-content h3 { font-size: 1.1em; }
			.memo-content h4 { font-size: 1em; }
			.memo-content h5 { font-size: 0.95em; }
			.memo-content h6 { font-size: 0.9em; }
			.memo-content a {
				color: var(--accent);
				text-decoration: none;
				border-bottom: 1px solid var(--accent);
			}
			.memo-content a:hover {
				text-decoration: underline;
			}
			.memo-content strong {
				font-weight: 600;
				color: rgb(var(--black));
			}
			.memo-content em {
				font-style: italic;
				color: rgb(var(--black));
			}
			.memo-content del {
				text-decoration: line-through;
				color: rgb(var(--gray));
			}
			.memo-content code {
				background: rgba(var(--gray), 15%);
				padding: 0.2em 0.4em;
				border-radius: 3px;
				font-family: 'Courier New', monospace;
				font-size: 0.9em;
				color: #d63384;
			}
			.memo-content pre {
				background: rgba(var(--gray), 10%);
				padding: 1rem;
				border-radius: 6px;
				overflow-x: auto;
				margin: 0.5rem 0;
			}
			.memo-content pre code {
				background: none;
				padding: 0;
				color: rgb(var(--black));
			}
			.memo-content ul,
			.memo-content ol {
				margin: 0.5em 0;
				padding-left: 1em;
			}
			.memo-content ul ul,
			.memo-content ul ol,
			.memo-content ol ul,
			.memo-content ol ol {
				padding-left: 1em;
			}
			.memo-content li {
				margin: 0.25em 0;
			}
			.memo-content blockquote {
				border-left: 3px solid var(--accent);
				padding-left: 1em;
				margin: 0.5em 0;
				color: rgb(var(--gray));
				font-style: italic;
			}
			.memo-content hr {
				border: none;
				border-top: 1px solid rgba(var(--gray), 25%);
				margin: 1em 0;
			}
			.memo-content img {
				max-width: 100%;
				height: auto;
				border-radius: 6px;
				margin: 0.5em 0;
			}
			.memo-attachments {
				display: flex;
				flex-wrap: wrap;
				gap: 0.5rem;
				margin-top: 0.75rem;
				justify-content: flex-start;
				align-items: flex-start;
			}
			.memo-attachment-img {
				cursor: pointer;
				height: auto;
				width: auto;
				border-radius: 8px;
				border: 1px solid rgba(var(--gray), 25%);
				object-fit: contain;
				transition: border-color 0.2s ease;
				max-height: 16rem;
				display: block;
			}
			.memo-attachment-img:hover {
				border-color: rgba(var(--gray), 40%);
			}
			.memo-tag-inline {
				background: rgba(var(--gray), 15%);
				color: rgb(var(--gray-dark));
				padding: 0.2em 0.4em;
				border-radius: 8px;
				font-weight: 500;
				font-size: 0.9em;
			}
			.empty-state {
				text-align: center;
				padding: 3rem 1rem;
				color: rgb(var(--gray));
			}
			.error-message {
				padding: 1rem;
				background: #fee;
				border: 1px solid #fcc;
				border-radius: 4px;
				color: #c00;
				margin-bottom: 1rem;
			}
			.loading {
				text-align: center;
				padding: 3rem 1rem;
				color: rgb(var(--gray));
			}
		</style>
	</head>
	<body>
		<Header />
		<main id="content">
			<div class="loading">加载中...</div>
		</main>
		<Footer />
		<script>
			interface Node {
				type: string;
				[key: string]: any;
			}

			interface Attachment {
				name: string;
				createTime: string;
				filename: string;
				content: string;
				externalLink: string;
				type: string;
				size: string;
				memo: string;
			}

			interface Memo {
				name: string;
				content: string;
				createTime: string;
				displayTime: string;
				visibility: string;
				tags?: string[];
				nodes?: Node[];
				attachments?: Attachment[];
			}

			/**
			 * 递归渲染 AST 节点为 HTML
			 * 参考 usememos/memos 的 node 结构
			 */
			function renderNode(node: Node, depth: number = 0): string {
				if (!node) return '';

				switch (node.type) {
					// 基础文本节点
					case 'TEXT':
						return escapeHtml(node.textNode?.content || '');

					// 换行
					case 'LINE_BREAK':
						return '<br />';

					case 'SOFT_LINE_BREAK':
						return ' ';

					// 段落
					case 'PARAGRAPH':
						if (node.paragraphNode?.children) {
							const children = node.paragraphNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<p>${content}</p>`;
						}
						return '';

					// 标题
					case 'HEADING':
						if (node.headingNode?.children) {
							const level = node.headingNode.level || 1;
							const children = node.headingNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<h${level}>${content}</h${level}>`;
						}
						return '';

					// 粗体
					case 'BOLD':
						if (node.boldNode?.children) {
							const children = node.boldNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<strong>${content}</strong>`;
						}
						return '';

					// 斜体
					case 'ITALIC':
						if (node.italicNode?.children) {
							const children = node.italicNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<em>${content}</em>`;
						}
						return '';

					// 删除线
					case 'STRIKETHROUGH':
						if (node.strikethroughNode?.children) {
							const children = node.strikethroughNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<del>${content}</del>`;
						}
						return '';

					// 内联代码
					case 'CODE':
						return `<code>${escapeHtml(node.codeNode?.content || '')}</code>`;

					// 代码块
					case 'CODE_BLOCK':
						const codeBlock = node.codeBlockNode;
						const language = codeBlock?.language || '';
						const codeContent = escapeHtml(codeBlock?.content || '');
						return `<pre><code class="language-${language}">${codeContent}</code></pre>`;

					// 链接
					case 'LINK':
						if (node.linkNode?.children) {
							const children = node.linkNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const linkContent = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							const url = escapeHtml(node.linkNode.url || '#');
							return `<a href="${url}">${linkContent}</a>`;
						}
						return '';

					// 超链接（自动链接）
					case 'AUTOLINK':
						const url = escapeHtml(node.autolinkNode?.url || '');
						return `<a href="${url}">${url}</a>`;

					// 图片
					case 'IMAGE':
						const imgUrl = escapeHtml(node.imageNode?.url || '');
						const imgAlt = escapeHtml(node.imageNode?.alt || '');
						return `<img src="${imgUrl}" alt="${imgAlt}" />`;

					// 标签
					case 'TAG':
						const tag = node.tagNode?.content || '';
						return `<span class="memo-tag-inline">#${tag}</span>`;

					// 列表容器
					case 'LIST':
						if (node.listNode?.children) {
							const ordered = node.listNode.ordered || false;
							// 过滤掉 LINE_BREAK 节点，只保留真实的列表项
							const listItems = node.listNode.children.filter((child: Node) => 
								child.type !== 'LINE_BREAK'
							);
							const items = listItems
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							const tag = ordered ? 'ol' : 'ul';
							return `<${tag}>${items}</${tag}>`;
						}
						return '';

					// 无序列表项
					case 'UNORDERED_LIST_ITEM':
						if (node.unorderedListItemNode?.children) {
							const children = node.unorderedListItemNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<li>${content}</li>`;
						}
						return '';

					// 有序列表项
					case 'ORDERED_LIST_ITEM':
						if (node.orderedListItemNode?.children) {
							const children = node.orderedListItemNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<li>${content}</li>`;
						}
						return '';

					// 任务列表项
					case 'TASK_LIST_ITEM':
						if (node.taskListItemNode?.children) {
							const children = node.taskListItemNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const checked = node.taskListItemNode.checked ? 'checked' : '';
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<li><input type="checkbox" ${checked} disabled /> ${content}</li>`;
						}
						return '';

					// 块引用
					case 'BLOCKQUOTE':
						if (node.blockquoteNode?.children) {
							const children = node.blockquoteNode.children;
							// 过滤掉开头和结尾的 LINE_BREAK 节点
							let startIdx = 0;
							let endIdx = children.length - 1;
							while (startIdx <= endIdx && children[startIdx]?.type === 'LINE_BREAK') startIdx++;
							while (endIdx >= startIdx && children[endIdx]?.type === 'LINE_BREAK') endIdx--;
							
							const filteredChildren = children.slice(startIdx, endIdx + 1);
							const content = filteredChildren
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
							return `<blockquote>${content}</blockquote>`;
						}
						return '';

					// 分割线
					case 'HORIZONTAL_RULE':
						return '<hr />';

					// 通用容器
					default:
						if (node.nodes && Array.isArray(node.nodes)) {
							return node.nodes
								.map((child: Node) => renderNode(child, depth + 1))
								.join('');
						}
						return '';
				}
			}

			/**
			 * 从 nodes AST 生成完整的 HTML
			 */
			function renderNodes(nodes: Node[] | undefined): string {
				if (!nodes || !Array.isArray(nodes)) {
					return '';
				}
				return nodes.map((node) => renderNode(node)).join('');
			}

			function escapeHtml(text: string): string {
				const div = document.createElement('div');
				div.textContent = text;
				return div.innerHTML;
			}

			function formatDate(dateString: string): string {
				try {
					const date = new Date(dateString);
					return date.toLocaleDateString('zh-CN', {
						year: 'numeric',
						month: 'long',
						day: 'numeric',
					});
				} catch {
					return dateString;
				}
			}

			function formatTime(dateString: string): string {
				try {
					const date = new Date(dateString);
					return date.toLocaleTimeString('zh-CN', {
						hour: '2-digit',
						minute: '2-digit',
					});
				} catch {
					return '';
				}
			}

			async function loadMemos() {
				const container = document.getElementById('content');
				if (!container) return;

				try {
					const response = await fetch('https://memos.ultraji.xyz/api/v1/memos?limit=100');
					if (!response.ok) {
						throw new Error(`API请求失败: ${response.status}`);
					}

					const data = await response.json();
					const memos: Memo[] = data.memos || [];

					if (memos.length === 0) {
						container.innerHTML = '<div class="empty-state"><p>暂无笔记</p></div>';
						return;
					}

					const memosHtml = memos
						.map((memo) => {
							// 优先使用 nodes AST，其次使用 content markdown
							let contentHtml = '';
							if (memo.nodes && Array.isArray(memo.nodes) && memo.nodes.length > 0) {
								contentHtml = renderNodes(memo.nodes);
							} else if (memo.content) {
								// 如果没有 nodes，使用 content 作为纯文本
								contentHtml = `<p>${escapeHtml(memo.content)}</p>`;
							}

					// 处理附件（图片）
					let attachmentsHtml = '';
					if (memo.attachments && Array.isArray(memo.attachments) && memo.attachments.length > 0) {
						const imageAttachments = memo.attachments.filter(att => att.type.startsWith('image/'));
						if (imageAttachments.length > 0) {
							const imagesHtml = imageAttachments.map(att => {
								const attachmentId = att.name.split('/')[1] || att.name;
								const imgUrl = `https://memos.ultraji.xyz/file/attachments/${attachmentId}/${encodeURIComponent(att.filename)}?thumbnail=true`;
								return `<img class="memo-attachment-img" src="${imgUrl}" alt="${escapeHtml(att.filename)}" title="${escapeHtml(att.filename)}" decoding="async" loading="lazy" />`;
							}).join('');
							attachmentsHtml = `<div class="memo-attachments">${imagesHtml}</div>`;
						}
					}

							return `<article class="memo-card"><div class="memo-header"><span class="memo-date">${formatDate(memo.displayTime || memo.createTime)}</span><span class="memo-time">${formatTime(memo.displayTime || memo.createTime)}</span></div><div class="memo-content">${contentHtml}${attachmentsHtml}</div></article>`;
					})
					.join('');

				container.innerHTML = `<div class="memos-list">${memosHtml}</div>`;
			} catch (err) {
				const errorMsg = err instanceof Error ? err.message : '未知错误';
				container.innerHTML = `<div class="error-message">获取笔记失败: ${errorMsg}</div>`;
				console.error('Failed to fetch memos:', err);
			}
		}

		loadMemos();
		</script>
	</body>
</html>
